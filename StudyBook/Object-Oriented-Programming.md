オブジェクト指向プログラミング

今回は、前回の教材でも言葉だけは出てきた「オブジェクト指向」というものについて学びます。

前回コードを実装するときには「クラス」の中に関数を作りましたが、「クラス」や「オブジェクト」とは何なのかを説明しませんでした。

今回は、これらについてきちんと知り、どのように使うのかを理解していきましょう。

目次
【講義】オブジェクト指向とは
【講義】オブジェクト指向を使う理由
【講義】クラスとインスタンス
【実習】クラスを作ってみよう
【講義】クラスの作り方
【実習】クラスからインスタンスを生成して使おう
【講義】クラスとインスタンスの使い方
【講義】Android フレームワークの API
【講義】オブジェクト指向とは
オブジェクト指向というソフトウェア開発の考え方は 1960 年代後半から 1970 年代にかけて生まれました。

当時は、開発されるソフトウェアが徐々に複雑で大規模化なものとなり、それまでのプログラミングの手法では限界を迎えつつありました。その問題を解決するために発明されたものがオブジェクト指向です。

それから数十年間をかけて広まり、今現在において主流のプログラミング言語ではオブジェクト指向を取り入れていない言語はほとんど存在しない、という状況です。

現在学んでいる Kotlin もオブジェクト指向言語です。「指向」という言葉が難しいですが、「それを中心にした」というような意味でとらえてください。

つまり、オブジェクト指向言語という言葉は「オブジェクトというものを中心にして、プログラミングをする言語」ということを言っています。

どういうことか、もう少し詳しく説明します。プログラムを作っていく基本手法として「部品化」があることは既に知っているかと思います。Web アプリケーション開発コースで学んだ JavaScript で言えば、名前をつけた関数で処理を部品化したり、関係した処理をファイルに分けてモジュールとして部品化したりしてきました。

しかし、どのような方針で部品化をするかは曖昧になっていました。小規模なプログラムであれば、その場の思いつきで処理を関数に分ける程度の部品化でもなんとかなります。一方で、より効率よく大規模なソフトウェアを開発するためには、部品化のやり方にも方針が必要になります。

オブジェクト指向は、その部品化の方針となるものです。つまり「オブジェクトを中心として部品化を行っていく」というプログラミングの手法・考え方のことなのです。

オブジェクトとモデル化
次は「オブジェクト」とは何のことなのかが気になるかと思います。まず英単語 object の日本語での意味ですが、シンプルに「もの」という意味です。「もの」という言葉は、現実世界のほとんどあらゆる物質や事柄を指すことができますね。

オブジェクトは、その現実世界のあらゆる「もの」をコンピューター上に表現したものです。人間・天体・食べ物・歌…、さまざまな「もの」をオブジェクト指向プログラミングではオブジェクトとして作り、扱うのです。

そんなこと不可能ではないか、と思う人がいるかもしれません。もちろん「もの」の持つ要素すべてを表現するのは不可能です。そうではなく、作成するプログラムで扱いたい要素にしぼって表現していくのです。

たとえば「歌」をオブジェクトに表現するなら、「タイトル」「歌詞」「歌手の名前」のような要素で表現していくことができます。そこには「この歌を歌手が歌ったときの、透き通るような歌声の素晴らしさ」などは含まれていませんが、作成しようとしているプログラムが「歌詞から歌を検索するプログラム」ならば「歌声」の情報は不要ですね。

このように必要な情報を分析し、適切な形で表現することをモデル化と呼びます。

オブジェクトは「もの」といっても、目に見える物質的な「もの」だけではなく、目に見えない「もの」も表現できるということに注意しましょう。

たとえば、先ほどの「歌」も目には見えないものですが、オブジェクトにできました。それと同様に「人間関係」「方程式」「戦略」のような抽象概念も、モデル化を行ってオブジェクトで表現できます。

オブジェクトの相互作用としてのシステム
以上のようにモデル化をすることで、抽象的なものも含めて、あらゆるものがオブジェクトとして表現できます。こうして「もの」がプログラム上でオブジェクトになると、それらの関係もプログラム上で表現できるのです。

たとえば「歌手は歌を歌う」という現実世界での関係を使って、「歌手」のオブジェクトに「歌」を歌え、と命令するような記述ができます。

オブジェクトの考え方を導入したことで、プログラムの書き方も行う処理を順に記述していくようなスタイル（手続き）から、オブジェクトの関係や振る舞いを記述するスタイル（オブジェクト指向）になるのです。

実のところ、オブジェクト指向をつきつめていくとシステムを構成する部品のすべてがオブジェクトとして表現され、それらのオブジェクト同士が連携して動作することで各機能が実現されることになります。

【講義】オブジェクト指向を使う理由
オブジェクト指向の考え方を少し説明してきましたが、そもそもなぜ、このような方針でプログラムを組むのでしょうか。

プログラムの部品化を行うための方針が必要である、という話は最初にしましたが、そこであえて「オブジェクト指向」を選ぶ理由は説明していませんでした。

オブジェクト指向を使う理由は、簡単にまとめてしまえば人間にとって直感的に理解がしやすいためです。

まずオブジェクト自体が「もの」として意味のまとまりをもっているので、人間がプログラムの意味を理解しやすいです。そして、オブジェクト同士が関係をもって何かを実現するというのも、現実世界をもとにイメージがしやすいのです。

例として、現実世界の車は、タイヤ・車体・エンジンなどの内部機構、ガソリン・電気などの燃料、ハンドル・アクセル・ブレーキなどの操作手段、そしてシートやライトなどの車内設備によって構成されています。これらがそれぞれ役割を持ち、お互いに組み合わさり、連携することによって「車」が実現できているわけです。

それと同様に、大きさや役割がさまざまに異なるオブジェクトがうまく連携しあい、ソフトウェアを構成するのがオブジェクト指向プログラミングなのです。役割が部品に分けられているので、大規模なソフトウェアになっても全体の把握がしやすいです。

このような人間にとっての理解のしやすさが、効率よい開発につながります。保守性・柔軟性・再利用性の向上などがオブジェクト指向のメリットとして一般的に挙げられますが、まずはその土台にある開発者にとってのわかりやすさに注目してほしいと思います。

【講義】クラスとインスタンス
ここまではオブジェクト指向そのものについて説明をしてきました。ここからは実際の Kotlin におけるオブジェクト指向プログラミングの方法を見ていきます。

Kotlin では主にオブジェクトを「クラス」と「インスタンス」というものを使って実現します。それぞれ、どういうものかを説明します。

クラスとは
クラスとは、モデル化を行って「もの」を表現した設計図で、後述するインスタンスを生成する役割を持ちます。プログラムのソースコードには、このクラスを書いていくことになります。

Kotlin でのクラスの書き方は、たとえば次のようになります。

class Cat {
    // プロパティと関数をここに書く
}

クラスの中ではデータを好きなだけ定義できます。Kotlin では、このデータのことをプロパティと呼び、操作する処理のことを関数と呼びます。

たとえば、「猫」というクラスを定義するとしたら、モデル化の一例としては次のようになります。

プロパティ
名前 (name)
年齢 (age)
性別 (gender)
品種 (breed)
関数
鳴く (say)
寝る (sleep)
この「猫」クラスは広く一般の「猫」という存在自体を表していて、名前のついた特定の猫（たとえば「タマ」のような猫）ではないことに注意してください。

「名前」などのプロパティは用意されていますが、それは「猫というものは、名前を持つ」ということを決めているだけです。猫クラスに「タマ」のような具体的な名前はまだ設定できません。

これが「クラスというのは設計図である」という説明の意味です。

インスタンスとは
インスタンスは、クラスをもとに生成された、実体となるオブジェクトです。1 つのクラスから、好きなだけインスタンスを作ることができます。

先ほどの例でいえば、猫クラスをもとにして猫インスタンスを作ることができます。次のような書き方でインスタンスが生成できます。

val cat = Cat()

Kotlin でのインスタンスの使い方については後ほど詳しく説明しますが、インスタンスでは定義されたプロパティに、実際に値を持たせられます。つまり、「3 才でオスの三毛猫タマ」「1 才でメスの黒猫クロ」のような特定の猫をオブジェクトとして表現できます。

慣れないうちは、クラスなど必要なくて直接インスタンスをソースコードに書ければいいのに、と感じるかもしれません。しかし、クラスという設計図を経由することで、複数のインスタンスを扱うことが楽になるのです。

たとえば猫が 100 匹いる状況で 1 匹ごとにその猫がどういうプロパティを持ち、どういう関数を持っているのか定義したら、ソースコードの量が無駄に増えてしまいます。

共通の性質は設計図となるクラスでまとめて書いておいて、個別に異なる部分はプロパティとして定義し、インスタンスごとに内容を変更する。この工夫をすることで、個別のオブジェクトの生成と管理が便利にできるのです。

自分で考えて理解しよう
クラスは設計図ですので、実際に値を入れたり、関数を呼び出したりするためのものではありません。プログラムの中から普段使うオブジェクトは、クラスから生成したインスタンスのほうです。インスタンスを使うために、その設計図となるクラスを実装するのです。

以上の、クラスとインスタンスの違いと使い分けは非常に重要です。混乱しそうなときには何度でもここまでの説明を読み返し、確実に理解するようにしてください。

オブジェクト指向は、特定の技術を指すわけではなくて、考え方です。ですので、単に文法や言葉を暗記しても役には立ちません。

「どうしてそうするのか」「どういう意味があるのか」を自分の頭でも考え、納得することがオブジェクト指向を学ぶためのポイントになります。

オブジェクトをどう分け、それぞれに何を担当させ、全体をどう連携させるか。これらをいつか自分で考えられるようになるためにも、1 つずつ理解していくようにしましょう。

オブジェクト指向は決して簡単ではありませんが、一度身に付ければ言語をまたいで活用できる知識となります。

【実習】クラスを作ってみよう
それでは、実際に Kotlin でクラスを作ってみましょう。先ほどの説明で出てきた、猫クラスを実際に作成します。

まず Android Studio を起動して、前回同様に My Application プロジェクトを開いてください。

開けたら Project ツールウィンドウの中から com.example.myapplication というフォルダを右クリックして、出てきたメニューから「New > Kotlin Class/File」と選択します。(androidTest) や (test) のように () のついたフォルダと間違わないように注意しましょう。

新しく Kotlin のクラスを作成するメニュー

すると次のようなダイアログが出てきますので、Name の欄に「Cat」と入れ、下欄のファイルの種類の中から「Class」が選択された状態で Enter を押しましょう。

Cat と入力して、クラスを作成する

これにより Project ツールウィンドウの com.example.myapplication の中に Cat という項目が追加されたかと思います。

Cat という項目が追加された

さらに、自動的にエディタウィンドウで Cat.kt が開かれます。Cat.kt の中を見ると

package com.example.myapplication

class Cat {
}

という、中身が空の Cat クラスが書かれた状態になっています。これを次のように実装してください。

package com.example.myapplication

import android.util.Log

class Cat(
    val name: String,
    val age: Int,
    val gender: String,
    val breed: String
) {
    fun say(message: String) {
        Log.d("Cat", "$name「$message」")
    }

    fun sleep() {
        say("Zzz")
    }
}

上記のコードを書いたときに、Android Studio からいくつか警告がでていても気にしないでください。あとで外部から Cat クラスを参照することで警告は消えます。

Log はインポートをしないと使えないクラスです。赤字になっていたら文字入力のカーソルを合わせて Alt + Enter（Mac では option + Enter）から import 文を追加しましょう。

Log ライブラリを import する

ここまでできたら、実行ボタンを押し、エラーが起こらずにアプリが起動することを確認してください。なお、ここではクラスを作成しただけなので、アプリの動作は何も変わっていません。

【講義】クラスの作り方
上記の手順でクラスの作成は完了ですが、少し解説をします。

Kotlin ではクラスの名前とファイルの名前は一致させることが一般的です。1 つのファイルに複数のクラスを書くことも可能ですが、その場合にはどれかのクラス名をファイル名にしておくのがわかりやすいでしょう。

また Kotlin ではクラスの名前は大文字で始めましょう。

class Cat {
  ...
}

のように、クラス名の部分 Cat の C が大文字になっていますね。

次にクラス宣言の冒頭を見ていきます

val name: String,
val age: Int,
val gender: String,
val breed: String

のように、まず変数宣言に似た書き方がされています。これはコンストラクタと呼ばれる部分で、クラスをインスタンス化するために必要なプロパティを定義しています。各プロパティにはそれぞれ型を明記して、どのような値が入ってくるのかを定義します。

そして、クラスの中には say() と sleep() という関数を記載しました。関数の文法については前回も学習したので省略します。

fun say(message: String) {
    Log.d("Cat", "$name「$message」")
}

say() の中で呼び出している Log.d() ですが、これはデバッグログへの文字列出力を担う Android の LogCat という機能の呼び出しです。JavaScript の console.log に相当するものだと考えてよいでしょう。

Log.d の中身を見てみると、第一引数の tag に Cat という文字列を入れています。これは、ログに Cat というタグをつけることで探しやすくしています。

また、第二引数の msg には $name「$message」 という記載をしました。これは Kotlin の文字列テンプレートという機能で、$ で変数を書くと変数がそのまま文字列として表示されます。なので、例えば name がタマ で message が こんにちは だった場合は、メッセージは タマ「こんにちは」 というように表示されます。

文字列テンプレートを使うことで、出力の文字が直感的にわかりやすくなるというメリットがあります。Cat クラスの説明は以上になります。

【実習】クラスからインスタンスを生成して使おう
作成した Cat クラスを使うコードを書いてみましょう。MainActivity.kt を開き、Greeting() の中身を次の処理に置き換えます。

fun Greeting(name: String, modifier: Modifier = Modifier) {
    val tama = Cat(name = "タマ", age = 3, gender = "オス", breed = "三毛猫")
    val kuro = Cat(name = "クロ", age = 1, gender = "メス", breed = "黒猫")

    tama.say("${tama.name}は${tama.gender}だにゃ")
    kuro.say("${kuro.name}は${kuro.gender}だにゃ")

    tama.sleep()
    kuro.say("寝てるし…")
    kuro.sleep()

   fun calculateFactorial(n: Int): Long {
       // 省略

解説は後にして、まずは実行ボタンでアプリを起動しエラーなく実行できるか確認してください。

今回は画面内のアプリの動作は変わっていませんが、LogCat によりログを出力しています。そのログを確認してみましょう。Android Studio の画面下部の「Logcat」タブで確認できます。

Logcat を開く

ここには自分でアプリ内に実装したコードからのログだけでなく、Android を動かす内部的なモジュールからのログも合わせて出力されます。覚えのない多くのログが表示されているのは、そのためです。ログの絞り込みを行う機能があるので、それを使って今自分が実装したログだけを表示するようにしてみましょう。

Logcat ツールウィンドウ上部の検索ボックスに、tag:Cat と入力してください。

tag:Cat と入力すると Cat を含む出力だけが抽出される

すると、今回実装したデバッグ出力の内容だけが表示されます。このように、開発中にちょっとしたデバッグ出力を行いたい場合は LogCat が便利です。

以上で、クラスからインスタンスを生成し、そのインスタンスを使って処理を行うという実装ができました。それでは、各コードについて解説していきます。

【講義】クラスとインスタンスの使い方
クラスを使うには、まずそのクラスのインスタンスを生成する必要があることは既に説明しました。それを行っているのが、以下の部分です。

val tama = Cat(name = "タマ", age = 3, gender = "オス", breed = "三毛猫")
val kuro = Cat(name = "クロ", age = 1, gender = "メス", breed = "黒猫")

まず、Cat( という部分に注目してください。ここで Cat というクラスをインスタンス化することを宣言しています。

引数にはそれぞれ名前を明記して値を渡しています。これは Cat クラスのコンストラクタである以下の定義と同じ変数名・型になっています。

class Cat(
    val name: String,
    val age: Int,
    val gender: String,
    val breed: String
){ 

つまり、どのような引数によってインスタンス化するのかを指定できるわけです。

ここで改めてコードを見直すと、Cat を 2 回インスタンス化していることがわかります。Cat クラスを元にして、tama と kuro という 2 つのインスタンスを作っています。

val tama = Cat(name = "タマ", age = 3, gender = "オス", breed = "三毛猫")
val kuro = Cat(name = "クロ", age = 1, gender = "メス", breed = "黒猫")

tama.say("${tama.name}は${tama.gender}だにゃ")
kuro.say("${kuro.name}は${kuro.gender}だにゃ")

これはつまり Cat クラスという「猫という存在のもと」を使って、それぞれ異なる名前や年齢などを持った、実体としての個別の猫（インスタンス）を 2 匹生み出したことになります。

ですので、生み出された tama と kuro は同じ Cat 型ではありますが、インスタンスとしては別のものが入っています。

たとえば、

tama の gender プロパティである tama.gender には「オス」
kuro の gender プロパティである kuro.gender には「メス」
が入っています。

このように、インスタンスのプロパティや関数を参照するためには . を使います。JavaScript で、オブジェクトからプロパティを参照する文法にそっくりですね。

tama.sleep()
kuro.say("寝てるし…")
kuro.sleep()

上記ではオブジェクト指向に沿っているため、tama と kuro のどちらからも say() と sleep() を使い回せます。インスタンスは別々なので、猫一匹ごとに異なる名前などのデータも、うまく管理できています。

今は 2 つしかインスタンスを作っていませんが、もっと大量のインスタンスを作ることになっても、この仕組みでうまくいきます。

さらに tama や kuro といった猫インスタンスが say() （話）をしたり、sleep() （寝る）をしたりすることが、わかりやすく表現できていることも重要です。処理の意味がソースコードから読み取りやすく、また書きやすいと感じるのではないでしょうか。

Kotlin ではこのように、クラスとインスタンスを使って賢く部品化を行っていくことができます。

Tips　同一パッケージ内の扱い
Cat クラスを MainActivity.kt から使う際に import 文は書かずに問題なく動作したことに気づいたでしょうか。

これは、Cat.kt と MainActivity.kt が同一のパッケージの com.example.myapplication に所属しているためです。
同一パッケージに公開されているクラスは import 文で指定をしなくても、単純名1で参照できます。

1. 単純名とは、パッケージ名を省略し、クラス名などの単一の識別子で書いた名前のことです。これに対し、import 文に書くような、パッケージ名から完全に書き下した名前のことを限定名と呼びます。 ↩
【講義】Android フレームワークの API
オブジェクト指向プログラミングについて理解できたところで、Android フレームワークの API について少し解説します。

ここまでは、Kotlin の標準機能と Android で提供される API の機能を特に区別せず説明してきました。しかし実際は、Android の API は Kotlin の標準機能などの上に構築されたフレームワークとなっていますので、これらは別のものです。

たとえば、LogCat は Android が用意した機能であり、アプリから使えるように API が提供されています。Cat.kt で Log クラスを使う際に自動で挿入された import 文を確認するとわかりますが、パッケージは android.util となっています。

Log クラスの import 文

他にも、Android アプリの画面を構築する ComponentActivity は、androidx.activity に所属しています。

このように Android の API は android または androidx から始まるパッケージで提供されます。Kotlin 標準のパッケージは kotlin で始まる名前になっていますので、ここで区別できます。

Android の API は Kotlin の機能や、オブジェクト指向を高度に活用しています。ですので、Android API を使って開発を進めるには、オブジェクト指向の考え方が必要となります。オブジェクト指向を理解することと、Android API を活用しアプリ開発を行うことは表裏一体なのです。

次の章では実際に本格的なアプリを作っていきますが、そこで使われているオブジェクト指向の考え方や、それを実現する Kotlin の機能も合わせて紹介・解説します。

それらは決して回り道ではなく、Android API を使いこなすために必要な知識であり効率よく開発をするために使える手法でもある、ということを覚えておいてください。

まとめ
オブジェクト指向は、オブジェクトに注目してプログラムを部品化して扱う考え方
Kotlin はオブジェクト指向言語であり、オブジェクトとしてクラスやインスタンスがある
クラスを実装し、そのクラスからインスタンスを生成することで、オブジェクトとして使うことができる
LogCat は Android でログを扱うための機能
挑戦　
初級
Cat クラスの sleep() の実装を変更し、年齢によって動作（出力される文字列）が変わるようにしてみましょう。

たとえば、年齢が 2 歳未満の子猫のときには、小文字で zzz、そうでなければ大文字で ZZZ のように出力するような仕様が考えられます。

中級
猫が自己紹介をする処理を Cat クラスに greet() として新規実装してみましょう。名前と性別だけでなく、年齢と品種もわかるように自己紹介させてください。

実装できたら greet() を使うように、 今回の学習で実装した say() の呼び出し箇所を以下のように変更して動作確認しましょう。

tama.greet()
kuro.greet()

上級
猫が、自分以外の猫についてどう思っているかを喋る talkAbout() を新規実装してみましょう。引数として別の猫のインスタンスを受け取る関数になります。

喋る内容を決定するルールは自由でよいですが、自分と性別や年齢などで比較して、それによって内容も変化するようなものが面白いでしょう。

実装できたら、実際に tama と kuro に対して talkAbout() を使ってみたり、さらに猫を追加して色々なパターンで期待通りの動作になるか試しましょう。

挑戦の解答例
答えを隠す

初級
Cat クラスに次のような実装をすることが考えられます。

 fun sleep() {
    if (age < 2) {
        say("zzz")
    } else {
        say("ZZZ")
    }
}

上記のように実装すると、sleep() の動作が変わったことで、実行した際の出力が以下のように変わります。

タマ「タマはオスだにゃ」

クロ「クロはメスだにゃ」

タマ「ZZZ」

クロ「寝てるし…」

クロ「zzz」

中級
Cat クラス内に以下のような greet() を追加します。

fun greet() {
    say("${age}才${gender}の${breed}、${name}だにゃ")
}

各プロパティを参照していることと、Cat クラスに既に定義されている say() を使って出力を行っているところがポイントです。各プロパティを {} で囲っているのは、プロパティ名がどこまでかを指定するためです。

tama.greet()
kuro.greet()

を MainActivity.kt で実行した結果は、

タマ「3才オスの三毛猫、タマだにゃ」

クロ「1才メスの黒猫、クロだにゃ」

このような出力になります。

データの扱いを関数に任せたことで、自己紹介をするという処理をうまくまとめることができ、呼び出し側のコードも簡潔になりました。

オブジェクト指向ではこのようにインスタンスのプロパティは外部から直接使わず、できるだけクラス内の実装から使うだけで済むように閉じこめる、ということが推奨されます。

この考え方を「カプセル化」と言いますが、詳しくはまた別の回に学習します。

上級
以下は引数に与えられた猫との年齢関係に注目してみた例です。

fun talkAbout(cat: Cat) {
    if (age > cat.age) {
        say("${cat.name}は後輩だにゃ")
    } else if (age < cat.age) {
        say("${cat.name}は先輩だにゃ")
    } else {
        say("${cat.name}とは同い年だにゃ")
    }
}

このように、Cat クラス自身の中でも Cat 型を使うことができます。cat には引数として与えられた猫インスタンスが入っていますので、 age > cat.age のような条件で両者の年齢を比較することができます。

この talkAbout() を試してみる確認用のコードは、例えば次のようになります。

val tama = Cat(name = "タマ", age = 3, gender = "オス", breed = "三毛猫")
val kuro = Cat(name = "クロ", age = 1, gender = "メス", breed = "黒猫")
val goro = Cat(name = "五郎", age = 3, gender = "オス", breed = "白猫")

tama.talkAbout(kuro)
tama.talkAbout(goro)
kuro.talkAbout(tama)
kuro.talkAbout(goro)

意味としては

タマから見た、クロの評価
タマから見た、五郎の評価
クロから見た、タマの評価
クロから見た、五郎の評価
を順に出力しており、その結果は以下のとおりです。

タマ「クロは後輩だにゃ」

タマ「五郎とは同い年だにゃ」

クロ「タマは先輩だにゃ」

クロ「五郎は先輩だにゃ」
このように、オブジェクト指向を活用した設計をすれば、 自分自身についてだけでなく、他のオブジェクトとの関わりによって何か処理をしたい場合にも、効率よくわかりやすい実装をすることができます。

お疲れさまでした！
学習したことをSNSで報告しよう！

